#+TITLE: lexical scoping and dynamic scoping in Emacs Lisp
#+URL: https://yoo2080.wordpress.com/2011/12/31/lexical-scoping-and-dynamic-scoping-in-emacs-lisp/   
#+AUTHOR: lujun9972
#+CATEGORY: raw
#+DATE: [2016-07-03 日 21:51]
#+OPTIONS: ^:{}


在本文中,我会演示:

1. Emacs Lisp中动态作用域与静态作用域之间的不同点
2. 实用动态作用域要当心什么
3. 静态作用域及静态闭包有什么用
4. 当混用静态作用域和动态作用域时,会发生什么情况

Emacs Lisp 在Emacs23及以下版本中只支持动态作用域. 直到Emacs24才开始支持静态作用域的. 这很好,因为静态作用域在大多数时候都要比动态作用域更清晰易懂.本文随后会解释这一点.
若你希望使用静态作用域,需要将 =-*- lexical-binding: t -*-= 放到el文件的第一行中. 这样当Emacs24加载该文件时,就会对里面的代码应用静态作用域了.
举个例子,我现在Emacs初始化文件中的第一行是

#+BEGIN_SRC emacs-lisp
  ;; -*- coding: utf-8 -*-
#+END_SRC

当我把这一行改成

#+BEGIN_SRC emacs-lisp
  ;; -*- coding: utf-8; lexical-binding: t -*-
#+END_SRC

则Emacs初始化文件中的代码被Emacs24加载时使用的是静态作用域了. 参见 [[http://www.gnu.org/software/emacs/manual/html_node/emacs/File-Variables.html][file variables]].

要实验一下静态作用域,第一步创建一个空的le文件(C-x C-f lexical-scratch.el RET), 然后添加下面这行内容:

#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t -*-
#+END_SRC

保存一下, 然后再revert一下这个buffer(M-x revert-buffer). 现在该buffer中的代码处于静态作用域下了,你可以在该buffer中做各种尝试了.

那么,什么是动态作用域,什么又是静态作用域呢? 我们来看个简单的例子吧.

#+BEGIN_SRC emacs-lisp
  (setq a 17)
  (defun my-print-a ()
    (print a))
  (setq a 1717)
  (let ((a 8))
    (my-print-a))
#+END_SRC

注意到在 =my-print-a= 中并未指定 =a= 变量的值,我们称呼其为“free variable”(自由变量) (也被称为 "nonlocal varibale"(非局部变量) 因为"=a= 不是在 =my-print-a= 函数内定义的"). 
上面代码的运行结果会是什么呢?会输出1717呢还是8? 在动态作用域下,它输出8,但在静态作用域下,输出为1717. 
在动态作用域下, =my-print-a= 中 =a= 所引用的值由 =my-print-a= 的调用环境所决定. 而在静态作用域下, =a= 的值由 =my-print-a= 的定义环境所决定.

在动态作用域下,该代码输出8是因为,调用 =my-print-a= 的时机,是在一个let语句中,在let语句内, =a= 的值被绑定到8. 若你是在let语句外面调用 =my-print-a= 则会输出1717.

在静态作用域下,代码输出1717是因为,首先, =my-print-a= 是在let语句外定义的,因此 =my-print-a= 中的 =a= 所引用的是 =a= 的全局绑定,而不是由let语句所创建的局部绑定(所谓绑定是指将名字 =a= 绑定到或分配给一块内存地址). 
其次,当 =my-print-a= 调用时, =a= 的全局的值变成了1717,它是与8这个局部值是相隔离的. 若你将 =my-print-a= 的定义移到let语句中,则输出的值会是8,这是因为这时 =my-print-a= 中的 =a= 引用的是let语句所创建的局部绑定.

如果你会JavaScript, 那么上面那段代码其实相当于下面这段JavaScript代码

#+BEGIN_SRC javascript
  var a;
  a = 17;
  function myPrintA() {
      console.log(a);
  }
  a = 1717;
  (function () {
      var a = 8;
      myPrintA();
  }());
#+END_SRC

这段JavaScript代码会输出 =1717=. 现在大多数的编程语言都是使用静态作用域的.

若你使用的是Emacs24, 你可以在scratch buffer中运行以下代码,来看看在静态作用域下,我上面的例子是否真的输出1717.

#+BEGIN_SRC emacs-lisp
  (eval
   '(progn
      (setq a 17)
      (defun my-print-a ()
        (print a))
      (setq a 1717)
      (let ((a 8))
        (my-print-a)))
   t)
#+END_SRC

Emacs24的 =eval= 函数可以接受第二个可选参数, 若该参数的值为t则表示在静态作用域下执行代码. 执行时,可别忘了 =(progn ...)前的'哦.

支持静态作用域是创建静态闭包的基础. 那么什么是静态闭包呢? 让我们看看下面这段代码:

#+BEGIN_SRC emacs-lisp
  (setq a 0)
  (let ((a 17))
    (defun my-print-a ()
      (print a))
    (setq a 1717))
  (let ((a 8))
    (my-print-a))
#+END_SRC

在静态作用域下,其输出为1717. 下面是Alice针对上面代码的解释:

#+BEGIN_QUOTE
咋一看,得出这个结果并不奇怪,但是若你仔细观察,就会发现有点奇怪了. 一开始,我想"这是静态作用域下,因此 =my-print-a= 中的 =a= 引用的是第一个let语句中创建的额局部绑定. 所以输出1717是理所当然的事情了"
但我再一看,发现 =my-print-a= 调用时,其中 =a= 所引用的由第一个let语句创建的局部绑定不是应该已经过期了吗? 你怎么可能还能使用过期的变量呢! 为什么会输出1717而不是提示"对不起,我已经不存在了"呢? 这里明明应该报错,为什么却没有呢?
#+END_QUOTE
   
第一个局部绑定通过某种方式在第一个let语句退出后还依然存在,并且只允许 =my-print-a= 来访问它. 这意味着Emacs肯定在低层维护着这些变量,这才使得静态作用域工作的要比想像中的更好.

那么,什么是静态闭包呢? 这与静态作用域的实现原理相关. =my-print-a= 的[[http://www.gnu.org/software/emacs/manual/html_node/elisp/Function-Cells.html][function cell]] 中包含了一个指向 =a= 的那个本应过期的绑定, 你可以通过执行 =(symbol-function 'my-print-a)= 来看到这一点.
这种结合函数定义以及指向函数创建时作用域的指针的组合物就叫做静态闭包. 你也可以称呼任何能访问已过期绑定的静态作用域函数为静态闭包. 静态闭包也简称闭包. 但并不是所有的静态作用域语言都支持闭包.

在静态作用域下,当你想看看函数体中某个变量引用的是什么东西时,你只需要看看函数体是在代码的哪个地方定义的,然后找到相关绑定即可. 这也是为什么静态作用域写的代码更清晰的原因,我们所要做的仅仅是看一下变量是在哪个位置定义就行了,也无需担心相关的绑定会过期.

总之,上面代码的用JavaScript表示就是:

#+BEGIN_SRC js
  var a, myPrintA;
  a = 0;
  (function () {
      // local variable a
      var a = 17;
      myPrintA = function () {
          console.log(a);
      };
      a = 1717;
  }());
  (function () {
      // local variable a
      var a = 8;
      myPrintA();
  }());
#+END_SRC

其输出结果为1717,因为JavaScript支持静态作用域.

在Emacs 24内部, 静态作用域函数是由格式为 =(closure ENV ARGS BODY...)= 的form来表示的, 而动态作用域函数是由格式为 =(lambda ARGS BODY...)= 的form来表示的(其格式与你在Emacs Lisp中书写的匿名函数是一样的).
下面这段代码在动态作用域下会输出 ~(lambda (x y) (+ x y))~ 两次,在静态作用域下会输出 ~(closure (t) (x y) (+ x y))~ 两次

#+BEGIN_SRC emacs-lisp
  (defun my-sum (x y)
    (+ x y))
  ;; print the contents of function cell of my-sum
  (print (symbol-function 'my-sum))
  ;; print an anonymous function
  (print (lambda (x y) (+ x y)))
#+END_SRC

貌似 =(lambda ...)= 语句的执行结果在动态作用域下就是它自己,而在动态作用域下则是 =(closure ...)=.

下面聊聊嵌套定义的情况. 在静态作用域下,若A函数定义了B函数(即是说B函数是在A函数的函数体中定义的),B函数又定义了C函数,那么当C函数输出 =a= 时,先会在函数C中查找 =a= 的引用,若没有找到,则会去函数B(函数C定义的位置)中查找 =a= 的引用,以此类推.

在动态作用域下,假设我们有一个函数 =my-func1=,这个函数调用了函数 =my-func2=, =my-func2= 函数又调用了 =my-func3=,函数 =my-func3= 输出 =a= 的值. =my-func2= 在调用 =my-func3= 时在本地设置 =a= 为2. 
那么在在动态作用域下调用 =my-func1= 会有什么结果呢? 它会输出 ~2~. 那么,若我是在一个将 =a= 设为1的环境调用 =my-func1=,又会是什么结果呢? 它还是输出2而不是1. 可以使用以下代码进行测试: 

#+BEGIN_SRC emacs-lisp
  (defun my-func1 ()
    (my-func2))
  (defun my-func2 ()
    (let ((a 2))
      (my-func3)))
  (defun my-func3 ()
    (print a))
  (let ((a 1))
    (my-func1))
#+END_SRC

其执行过程是这样的,在将 =a= 局部绑定为1的情况下调用 =my-func1= ,然后 =my-func1= 又调用 =my-func2=. 接下来, =my-func2= 为a又创建了一个局部绑定,从而屏蔽了之前那个将 =a= 绑定为1的局部绑定了.
这个执行时点,就好像是 =(let ((a 1)) (let ((a 2)) X ))= 中的X一样,在这个时点调用 =my-func3= 当然会输出2了.

动态作用域有一个弊端你应该知道的. 假设你你想调用一个以函数为参数的函数.

#+BEGIN_SRC emacs-lisp
  (defun my-call (f n)
    (funcall f n))

  (my-call #'1+ 5) ; => 6
  (my-call #'oddp 5) ; => t

  (dolist (i (list 1 2 3))
    (print
     (my-call (lambda (x) (* i x)) 5))) ; 输出 5 10 15
#+END_SRC

目前看来没什么问题. 接下来我们试试

#+BEGIN_SRC emacs-lisp
  (dolist (n (list 1 2 3))
    (print
     (my-call (lambda (x) (* n x)) 5))) ; 动态作用域下会输出 25 25 25
#+END_SRC

怎么会这样? 问题的关键在于 =(lambda (x) (* n x))= 中的 =n= 与 =my-call= 中的参数同名了. 匿名函数 =(lambda (x) (* n x))= 是在 =my-call= 中被调用的,而 =my-call= 函数内,参数 =n= 被绑定成了5了. 
在静态作用域中上面代码会如愿输出 ~5 10 15~

缺陷 1 – 将一个动态作用域下的函数作为参数传递給另一个函数可能会有问题!
(Update: 所谓动态作用域下的函数是指在动态作用域文件中定义的函数. 所以与其从函数的角度来思考这个问题不如从动态作用域文件对比静态作用域文件的角度来思考这个问题. 
或者更精确一点, 是动态作用域elisp buffer中的动态作用域代码 vs 静态作用域elisp buffer中的静态作用域代码
请参见 [[http://stackoverflow.com/questions/7654848/what-are-the-new-rules-for-variable-scoping-in-emacs-24][http://stackoverflow.com/questions/7654848/what-are-the-new-rules-for-variable-scoping-in-emacs-24]]
)

让我们来看另一个问题. 尝试定义一个函数,其接受两个函数f和g,并返回一个组合函数等价于先调用g函数然后再用结果调用f函数.

#+BEGIN_SRC emacs-lisp
  ;; in dynamic scoping
  (defun my-compose (f g)
    (lambda (x)
      (funcall f (funcall g x))))

  (funcall
   (my-compose (lambda (n) (+ n 3)) (lambda (n) (+ n 20)))
   100) ; 结果报错, Lisp error: (void-variable f)
#+END_SRC

错误信息告诉我们 =f= 没有定义. 为什么会这样? 因为组合函数是在 =my-compose= 中创建的, 但是在另一个 =f= 和 =g= 都没有绑定的地方调用的.
当然,如果是静态作用域,则上面代码运行结果与预期一样.

缺陷 2 – 使用从动态作用域函数返回的函数可能会有问题!

在Emacs 24中, =defvar= 创建的变量称为 =special variables=. =Special variables= 是动态作用域变量,即使它在静态作用域函数中创建的绑定也是动态绑定.
=case-fold-search= 就是个special variable的例子. 函数 =search-forward= 是否大小写敏感依赖于 =case-fold-search= 的值. 当 =case-fold-search= 设为t时, =(search-forward "hello")= 能够匹配"HELLO", 当 =case-fold-search= 为 nil时则不匹配. 
假设你在静态作用域下的el文件中定义自己的 =my-search-forward= 函数,且在 =my-search-forward= 中也使用 =case-fold-search= 来决定是否大小写敏感. 由于 =case-fold-search= 为special variable, 因此当你调用

#+BEGIN_SRC emacs-lisp
  (let ((case-fold-search t))
    (my-search-forward "hello"))
#+END_SRC

你可以确定该搜索是大小写不敏感的.

你可以使用函数 =special-variable-p= 来判断一个变量是否special.

#+BEGIN_SRC emacs-lisp
  (special-variable-p 'print-level) ; => t
  (special-variable-p 'print-length) ; => t
  (special-variable-p 'debug-on-error) ; => t
  (special-variable-p 'debug-on-quit) ; => t
#+END_SRC

Special variables某些情况下很有用. [[http://www.reddit.com/r/programming/comments/ggmc2/emacs_lisp_now_lexically_scoped_oh_very_funny_no/c1nfngv][gsg在reddit中曾经说过]]:

#+BEGIN_QUOTE
    动态作用域允许你給参数化代码而无需明确地传递一个参数. 把这种方式作为默认的行为不太好,但是有些代码确实能因此而收益.
#+END_QUOTE
   
[[http://www.reddit.com/r/programming/comments/ggmc2/emacs_lisp_now_lexically_scoped_oh_very_funny_no/c1nkdcu][kragensitaker也说过]]:

#+BEGIN_QUOTE
    有些情况下需要使用动态作用域,例如Thread-local变量, 异常处理器, 当前语言环境, 当前选中的区域 以及图形转换等.
#+END_QUOTE
   
接下来让我们看看静态作用域有什么用.

在静态作用域下运行下面代码.

#+BEGIN_SRC emacs-lisp
  (let (c)
    (defun my-get-c ()
      c)
    (defun my-set-c (new-c)
      (setq c new-c))
    (defun my-add-to-c (x)
      (setq c (+ x c))))
#+END_SRC

然后在下面的代码中使用这三个函数. 由于在动态作用域下调用的静态函数依然是静态函数(Update:也许这样解释比较好:函数调用仅仅只是调用函数而已,它仅仅执行函数体的代码,二不会改变函数体的代码. 函数体依然处于静态作用域环境下. 因此,函数体中的变量(special varialbe除外)依然是引用的静态绑定),因此不管你是否在静态作用域下运行,其结果都是一样的.

#+BEGIN_SRC emacs-lisp
  (my-set-c 10)
  (my-add-to-c 5)
  (print (my-get-c)) ; prints 15.
  (my-add-to-c 1)
  (print (my-get-c)) ; prints 16
  (let ((c 0))
    (print c) ; prints 0
    (print (my-get-c))) ; prints 16.
#+END_SRC

=my-get-c=, =my-set-c=, 和 =my-add-to-c= 共享同一个 =c= 绑定,这使得 =c= 就好像是一个私有变量一样, 并且与其他名为 =c= 的绑定(例如 =(let ((c 0)) ...)= 中的c)相独立.
之所以会这样是因为创建这个c绑定的let语句包含了这三个 =defun= 语句,因此除了这三个函数能访问以外,对于其他的访问来说 =c= 以及过期了.

Now let’s test using lexical closures to do what static variables in C do.

#+BEGIN_SRC emacs-lisp
  (require 'cl) ; for incf
  (eval
   '(let ((i 0))
      (defun my-counter ()
        (prog1
            i
          (incf i))))
   t)
  (my-counter) ; => 0
  (my-counter) ; => 1
  (my-counter) ; => 2
  (let ((i 10))
    (my-counter)) ; => 3
  (my-counter) ; => 4
#+END_SRC

若你觉得很奇怪,为什么上面代码的输出是这样的,请看下面的演示案例.

#+BEGIN_SRC emacs-lisp
  (eval
   '(let ((i1 0))
      (defun my-test ()
        (let ((i2 0))
          (prog1
              (list i1 i2)
            (incf i1)
            (incf i2)))))
   t)
  (my-test) ; => (0 0)
  (my-test) ; => (1 0)
  (my-test) ; => (2 0)
#+END_SRC

我们定义了 =my-test= 函数,然后调用这个函数三次. =my-test= 中的let语句 =(let ((i2 0)) ..)= 也随之执行了三次. 另一方面,let语句 =(let ((i1 0)) ... )= 仅仅在定义 =my-test= 时执行了一边. 我希望这个例子能有助于你的理解.

下面让我们测试一个返回闭包函数的函数.

#+BEGIN_SRC emacs-lisp
  (eval
   '(defun my-get-counter (start step)
      (let ((count start))
        (lambda ()
          (prog1
              count
            (setq count (+ count step)))))
      )
   t)

  (setq my-get-even-numbers (my-get-counter 0 2)
        my-get-odd-numbers (my-get-counter 1 2))

  (funcall my-get-even-numbers) ; => 0
  (funcall my-get-even-numbers) ; => 2
  (funcall my-get-even-numbers) ; => 4

  (funcall my-get-odd-numbers) ; => 1
  (funcall my-get-odd-numbers) ; => 3
  (funcall my-get-odd-numbers) ; => 5

  (funcall my-get-even-numbers) ; => 6
  (funcall my-get-even-numbers) ; => 8

  (setq my-get-even-numbers-2 (my-get-counter 0 2))
  (funcall my-get-even-numbers-2) ; => 0
  (funcall my-get-even-numbers-2) ; => 2
  (funcall my-get-even-numbers-2) ; => 4

  (funcall my-get-even-numbers) ; => 10
  (funcall my-get-even-numbers) ; => 12
  (funcall my-get-even-numbers) ; => 14
#+END_SRC

你可能会觉得奇怪,为什么 =my-get-even-numbers=, =my-get-odd-numbers= 以及 =my-get-even-numbers-2= 看起来有自己独立的 =count= 变量一样,而不是共享同一个 =count= 变量呢?
答案是,它们确实有自己独立的 =count= 变量. 若你感到困惑不解, 你可以试试在静态作用域下执行以下代码,看结果是什么.

#+BEGIN_SRC emacs-lisp
  (let ((count 0))
    (setq my-count
          (lambda ()
            (prog1
                count
              (setq count (1+ count))))))
  (let ((count 0))
    (setq my-count-2
          (lambda ()
            (prog1
                count
              (setq count (1+ count))))))
#+END_SRC

=my-count= 与 =my-count-2= 都有它们自己独立的 =count= 变量. 这两个let语句各自包含了各自的 =(setq .. (lambda ...))= 语句. 这与 =my-get-counter= 是一样的请看. 每次执行 =(my-get-counter ..)= 都会执行一次 =(let ((count ..)) (lambda ..))=, 每次都会为 =count= 创建一个新的独立的绑定給新返回的函数访问. 当你调用 =(my-get-counter ..)= 三次, =(let ((count ..)) (lambda ..))= 也被执行了三次, 创建了三个 =count= 绑定和三个返回的函数.

Alice现在写的所有Emacs Lisp代码都使用静态作用域. 那么当混用静态作用域代码和动态作用域代码时,会有什么后果呢?

让我们从一个简单的例子开始.

#+BEGIN_SRC emacs-lisp
  (eval
   '(defun my-bah ())
   t)

  (eval
   '(fset 'my-bah-2 (symbol-function 'my-bah))
   nil)
#+END_SRC

函数 =my-bah= 是定义在静态作用域环境的. 因此它肯定是静态作用域函数. 那么 =my-bah-2= 呢? Alice认为"函数 =my-bah-2= 是在动态作用域环境下定义的,因此它肯定是动态作用域函数". 但是另一方面,Bob认为"=my-bah-2= 中function-cell的内容就是拷贝的 =my-bah= 中function cell的内容. 及润 =my-bah= 中function-cell的内容是静态作用域函数,那么 =my-bah-2= 中function cell的内容也应该是静态作用域函数". Alice说"目前这些函数啥都不干,让我们修改一下它们,让它们通过返回值告诉我们它们是否处于静态作用域下"

下面这段代码在静态作用域下会返回t,否则返回nil. [[https://yoo2080.wordpress.com/2011/12/30/how-to-check-dynamically-if-lexical-scoping-is-active-in-emacs-lisp/][Checking the value of lexical-binding instead here is a bad idea.]] 

#+BEGIN_SRC emacs-lisp
  (let ((x nil)
        (f (let ((x t)) (lambda () x))))
    (funcall f))
#+END_SRC

  Alice 修改了一下 =my-bah= 以及 =my-bah-2= 的代码.

#+BEGIN_SRC emacs-lisp
  (eval
   '(defun my-bah ()
      (let ((x nil)
            (f (let ((x t)) (lambda () x))))
        (funcall f)))
   t)

  (eval
   '(fset 'my-bah-2 (symbol-function 'my-bah))
   nil)
#+END_SRC

让我们看看 =my-bah-2= 是否是静态作用域函数.

#+BEGIN_SRC emacs-lisp
  (my-bah) ; => t
  (my-bah-2) ; => t
#+END_SRC

看起来Bob是对的. 让我们不用 =defun= 再试一次.

#+BEGIN_SRC emacs-lisp
  (eval
   '(setq my-nah
          (lambda ()
            (let ((x nil)
                  (f (let ((x t)) (lambda () x))))
              (funcall f))))
   t)

  (eval
   '(setq my-nah-2 my-nah)
   nil)

  (funcall my-nah) ; => t
  (funcall my-nah-2) ; => t
#+END_SRC

When you run (setq abc (+ 1 1)), the expression (+ 1 1) describing a sum is evaluated first, and then
the evaluation result 2, a number, is assigned to the variable abc. Likewise, when you run (setq my-nah
(lambda ...)), the expression (lambda ...) describing an anonymous function is evaluated first. In
lexical scoping, the evaluation result is something that looks like (closure ....), a lexically scoped
function value. Then that result (closure ....) is assigned to the variable my-nah.

When you run (setq abc (+ 1 1)) and then run (setq abc-2 abc), evaluation of the expression (+ 1 1)
happens only once. The statement (setq abc-2 abc) does not evaluate (+ 1 1) again, it just saves the
already computed result 2 to abc-2. What it does evaluate is the symbol abc itself, and the symbol abc
evaluates to 2. Likewise, in the my-nah & my-nah-2 example code, evaluation of the expression (lambda
...) happens only once and the result (closure ...) is not evaluated when you run (setq my-nah-2
my-nah), it is simply saved to my-nah-2. Even though (setq my-nah-2 my-nah) is run in a dynamically
scoped environment, because evaluation of the anonymous function expression happens in a lexically
scoped environment, the variable my-nah-2 ends up holding a lexically scoped function.

A lexically scoped function is created and it gets passed around in a dynamically scoped environment,
and the function remains a lexically scoped function.

The defun my-bah example is similar. The function cell of the symbol my-bah holds a lexically scoped
function, which simply gets passed around. Check with the following test.

#+BEGIN_SRC emacs-lisp
  (print my-nah-2)
  (print (symbol-function 'my-bah-2))
#+END_SRC

So when you have a defun in a lexically scoped el file, to see the meaning of free variables names in
it, you just look around them in the el file, regardless of whether that function gets another name in
a dynamically scoped file.

Now that my-nah-2 & my-bah-2 example is understood, let’s revisit my-get-counter. As long as (defun
my-get-counter ...) is in a lexically scoped el file, functions returned by my-get-counter are
lexically scoped. Let’s see.

#+BEGIN_SRC emacs-lisp
  (eval
   '(progn
      (setq my-get-even-numbers (my-get-counter 0 2))
      (print (funcall my-get-even-numbers))
      (print (funcall my-get-even-numbers))
      (print (funcall my-get-even-numbers)))
   nil)
#+END_SRC

That prints 0 2 4. Alice’s argument repeated here would be like “The function my-get-even-numbers is
defined in a dynamically scoped environment. So why is it acting like a lexically scoped function?” The
variable my-get-even-numbers ends up holding a lexically scoped function for the same reason my-nah-2
does. In case you are confused, let’s get our head around my-get-sum first.

#+BEGIN_SRC emacs-lisp
  (defun my-get-sum (x y)
    (+ x y))
#+END_SRC

(+ x y) in my-get-sum is an expression describing a sum and my-get-sum returns the result of evaluation
of (+ x y), not the expression (+ x y) itself. When you run (my-get-sum 1 2), it does not return the
literal expression (+ x y), it returns 3, which is what (+ x y) evaluated to inside my-get-sum.

Back to my-get-counter. (lambda ...) in my-get-counter is an expression describing an anonymous
function. That expression is evaluated once inside my-get-counter. The result of its evaluation is
something that looks like (closure ...) which is immediately returned and gets stored in the variable
my-get-even-numbers. Evaluation of the (lambda ...) happens only once and that happens inside the
lexically scoped function my-get-counter. Evaluation of a lambda form inside a lexically scoped
function always results in (closure ...). That is how my-get-even-numbers ends up holding a lexically
scoped function.

By the way, lexically scoped functions can create and return a dynamically scoped function if the
evaluation of a lambda form is somehow avoided maybe unintentionally.

#+BEGIN_SRC emacs-lisp
  (eval
   '(defun my-return-dynamically-scoped-function ()
      (list 'lambda '() 'a)
      )
   t)

  (eval
   '(defun my-return-dynamically-scoped-function ()
      '(lambda () a) ; quoted lambda
      )
   t)
#+END_SRC

I don’t know why anybody would do that intentionally, but it can be done.

Now let’s revisit the my-call example.

#+BEGIN_SRC emacs-lisp
  (eval
   '(defun my-call (f n)
      (funcall f n))
   nil)

  (eval
   '(dolist (n (list 1 2 3))
      (print
       (my-call (lambda (x) (* n x)) 5)))
   t)
#+END_SRC

That prints 5 10 15. Alice argument repeated would be “The function f is defined in a dynamically
scoped environment. So why is it acting like a lexically scoped function?”. The anonymous functions to
be passed to my-call are defined in a lexically scoped environment, so it stays as a lexically scoped
function even after it is passed to my-call. In case you are still confused, the (lambda ...) is
evaluated and then its result is passed to my-call. my-call stores the result to its local variable f.
So f ends up referring to a lexically scoped function.

The function mapcar* is like my-call in that it accepts a function as an argument and is defined in a
dynamically scoped el file (for now). The following dynamic scoping gotcha example is from [[http://stackoverflow.com/a/3791877/37664][some]]
[[http://stackoverflow.com/a/3791877/37664][StackOverflow answer]].

#+BEGIN_SRC emacs-lisp
  (let ((cl-x 10))
    (mapcar* (lambda (elt) (* cl-x elt)) '(1 2 3)))
#+END_SRC

The name cl-x is also used as an argument name in the definition of mapcar*. So running the code above
in a dynamically scoped environment leads to a surprise (Gotcha 1). But when you run the code in a
lexically scoped environment, it works fine, because lexically scoped anonymous functions passed to
mapcar* stays as lexically scoped functions.

Judging by these examples, it seems that lexically scoped code blend in well. Time to go forth and
enjoy lexical scoping!

(Update: See also: [[https://yoo2080.wordpress.com/2013/08/14/invasion-of-special-variables-in-emacs-lisp/][Invasion of special variables]] which shows other pitfalls and what can be done about
them )

